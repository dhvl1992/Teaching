<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best-First Search - Friend Recommendation System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Georgia, serif;
            background: linear-gradient(135deg, #FEF7ED 0%, #1E293B 100%);
            min-height: 100vh;
            color: #1E293B;
            line-height: 1.6;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 100vh;
            gap: 2px;
        }

        .panel {
            padding: 30px;
            overflow-y: auto;
        }

        .left-panel {
            background: #FEF7ED;
        }

        .right-panel {
            background: #1E293B;
            color: #FEF7ED;
        }

        .header {
            text-align: center;
            padding: 30px;
            background: #1E293B;
            color: #FEF7ED;
            border-radius: 15px;
            margin-bottom: 30px;
            border-left: 5px solid #3B82F6;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .header:hover {
            transform: translateY(-5px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            font-style: italic;
        }

        .section {
            background: #FEF7ED;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border-left: 5px solid #3B82F6;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
        }

        .theory-section {
            background: rgba(5, 150, 105, 0.05);
            border-left: 5px solid #059669;
        }

        .section h2 {
            font-size: 2.2em;
            color: #1E293B;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3B82F6;
        }

        .theory-section h2 {
            border-bottom: 3px solid #059669;
        }

        .section h3 {
            font-size: 1.4em;
            color: #1E293B;
            margin: 20px 0 10px 0;
        }

        .code-section {
            background: #0F172A;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            position: relative;
            border-left: 5px solid #059669;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .code-section:hover {
            transform: translateY(-5px);
        }

        .code-block {
            background: #000;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            color: #FEF7ED;
        }

        .social-network-container {
            background: #FEF7ED;
            border: 2px solid #3B82F6;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .network-svg {
            width: 100%;
            height: 500px;
            background: #ffffff;
            border-radius: 10px;
            border: 2px solid #E2E8F0;
        }

        .person-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .person-node.target { fill: #3B82F6; stroke: #1D4ED8; stroke-width: 3; }
        .person-node.friend { fill: #10B981; stroke: #059669; stroke-width: 2; }
        .person-node.candidate { fill: #F59E0B; stroke: #D97706; stroke-width: 2; }
        .person-node.evaluating { 
            fill: #EF4444; 
            stroke: #DC2626; 
            stroke-width: 4;
            animation: pulse 1s infinite;
        }
        .person-node.recommended { fill: #8B5CF6; stroke: #7C3AED; stroke-width: 3; }

        .connection {
            stroke: #94A3B8;
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .connection.active { stroke: #3B82F6; stroke-width: 3; }
        .connection.mutual { stroke: #10B981; stroke-width: 3; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: #3B82F6;
            color: #FEF7ED;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-family: Georgia, serif;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .btn:hover { 
            background: #2563EB;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .btn:disabled { 
            background: #9CA3AF; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }

        .user-profiles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .profile-card {
            background: rgba(59, 130, 246, 0.05);
            border: 2px solid #3B82F6;
            border-radius: 10px;
            padding: 15px;
            border-left: 5px solid #3B82F6;
        }

        .profile-card h4 {
            color: #3B82F6;
            margin-bottom: 10px;
            text-align: center;
        }

        .profile-info {
            font-size: 12px;
            line-height: 1.4;
        }

        .step-info {
            background: rgba(5, 150, 105, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: none;
            border-left: 5px solid #059669;
            border: 2px solid #059669;
        }

        .step-info.show { display: block; }

        .result {
            background: #059669;
            color: #FEF7ED;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            display: none;
            border-left: 5px solid #047857;
            box-shadow: 0 8px 25px rgba(5, 150, 105, 0.3);
        }

        .result.show { display: block; }

        .result h3 {
            color: #FEF7ED;
            font-size: 1.6em;
            margin-bottom: 15px;
        }

        .scoring-display {
            background: rgba(234, 88, 12, 0.05);
            border: 2px solid #EA580C;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .scoring-display.show { display: block; }

        .scoring-display h4 {
            color: #EA580C;
            margin-bottom: 15px;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #E2E8F0;
        }

        .score-item:last-child { border-bottom: none; }

        .score-item.highlight { 
            background: #FEF3C7; 
            font-weight: bold;
            border-radius: 5px;
            padding: 8px 10px;
        }

        .formula {
            background: #1E293B;
            color: #FEF7ED;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 20px 0;
            font-size: 16px;
            border-left: 5px solid #3B82F6;
            box-shadow: 0 4px 15px rgba(30, 41, 59, 0.3);
        }

        .highlight-box {
            background: #059669;
            color: #FEF7ED;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
            border-left: 5px solid #047857;
        }

        .accent-box {
            background: #3B82F6;
            color: #FEF7ED;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-style: italic;
            border-left: 5px solid #2563EB;
        }

        .content-list {
            list-style: none;
            padding-left: 0;
        }

        .content-list li {
            position: relative;
            padding-left: 30px;
            margin-bottom: 12px;
        }

        .content-list li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #3B82F6;
            font-weight: bold;
            font-size: 1.2em;
        }

        .copy-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #3B82F6;
            color: #FEF7ED;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-family: Georgia, serif;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: #2563EB;
        }

        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
            .user-profiles { grid-template-columns: 1fr; }
            .panel { padding: 20px; }
            .header h1 { font-size: 2em; }
            .section { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="panel left-panel">
            <div class="header">
                <h1>Best-First Search</h1>
                <p>Smart Friend Recommendation System</p>
            </div>

            <div class="section">
                <h2>🎯 Aim</h2>
                <p><strong>To understand and implement the Best-First Search algorithm for recommending friends in a simulated social network using heuristic scoring based on mutual friends, shared location, and common technical skills.</strong></p>
                
                <div class="highlight-box">
                    <strong>Objective:</strong> Demonstrate how Best-First Search uses intelligent heuristics to make friend recommendations, similar to how LinkedIn suggests professional connections by analyzing technical skills, education, and professional relationships.
                </div>
            </div>

            <div class="section theory-section">
                <h2>📚 Theory: Best-First Search in Social Networks</h2>
                
                <h3>What is Best-First Search?</h3>
                <p>Best-First Search is an informed search algorithm that uses heuristic evaluation to decide which node to expand next. In friend recommendation systems, it evaluates potential friends using social data.</p>

                <div class="formula">
                    Friend Score = 10×(Mutual Friends) + 5×(Same City) + 2×(Common Skills)
                </div>

                <h3>Key Components:</h3>
                <ul class="content-list">
                    <li><strong>Social Graph:</strong> Network of people and their relationships</li>
                    <li><strong>Heuristic Function:</strong> Scoring system based on social similarity</li>
                    <li><strong>Greedy Selection:</strong> Always picks the highest-scoring candidate next</li>
                    <li><strong>Friends-of-Friends:</strong> Explores second-degree connections</li>
                </ul>

                <h3>Scoring System Breakdown:</h3>
                <div style="margin: 15px 0;">
                    <strong>Mutual Friends (+10 each):</strong> People with common friends are more likely to connect.
                </div>
                <div style="margin: 15px 0;">
                    <strong>Same City (+5):</strong> Geographic proximity increases friendship probability.
                </div>
                <div style="margin: 15px 0;">
                    <strong>Common Skills (+2 each):</strong> Shared technical skills create professional connections.
                </div>

                <h3>Algorithm Properties:</h3>
                <ul class="content-list">
                    <li><strong>Informed:</strong> Uses social data to make intelligent decisions</li>
                    <li><strong>Greedy:</strong> Always selects the most promising candidate</li>
                    <li><strong>Efficient:</strong> Focuses on high-potential connections first</li>
                    <li><strong>Practical:</strong> Models real-world recommendation systems</li>
                </ul>

                <div class="accent-box">
                    <strong>Real-world Application:</strong> This exact approach is used by social media platforms to suggest friends, professional connections, and content recommendations by analyzing user behavior and relationship patterns.
                </div>
            </div>

            <div class="section">
                <h2>👥 Interactive Social Network</h2>
                <div class="social-network-container">
                    <h3 style="text-align: center; color: #1E293B; margin-bottom: 20px;">Social Network Graph</h3>
                    
                    <svg class="network-svg" viewBox="0 0 600 500">
                        <!-- Background grid -->
                        <defs>
                            <pattern id="socialGrid" width="20" height="20" patternUnits="userSpaceOnUse">
                                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f1f5f9" stroke-width="1"/>
                            </pattern>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#socialGrid)" />
                        
                        <!-- Connections -->
                        <g class="connections">
                            <!-- Direct friends of Rahul -->
                            <line x1="300" y1="250" x2="200" y2="150" class="connection" data-from="Rahul" data-to="Priya"/>
                            <line x1="300" y1="250" x2="400" y2="150" class="connection" data-from="Rahul" data-to="Aman"/>
                            
                            <!-- Priya's connections -->
                            <line x1="200" y1="150" x2="100" y2="100" class="connection" data-from="Priya" data-to="Neha"/>
                            <line x1="200" y1="150" x2="150" y2="50" class="connection" data-from="Priya" data-to="Ravi"/>
                            
                            <!-- Aman's connections -->
                            <line x1="400" y1="150" x2="500" y2="100" class="connection" data-from="Aman" data-to="Simran"/>
                            <line x1="400" y1="150" x2="450" y2="50" class="connection" data-from="Aman" data-to="Kiran"/>
                        </g>
                        
                        <!-- People -->
                        <g class="people">
                            <!-- Target user -->
                            <circle cx="300" cy="250" r="25" class="person-node target" data-person="Rahul"/>
                            <text x="300" y="255" text-anchor="middle" fill="white" font-weight="bold" font-size="14">R</text>
                            <text x="300" y="285" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Rahul</text>
                            
                            <!-- Direct friends -->
                            <circle cx="200" cy="150" r="20" class="person-node friend" data-person="Priya"/>
                            <text x="200" y="155" text-anchor="middle" fill="white" font-weight="bold" font-size="12">P</text>
                            <text x="200" y="130" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Priya</text>
                            
                            <circle cx="400" cy="150" r="20" class="person-node friend" data-person="Aman"/>
                            <text x="400" y="155" text-anchor="middle" fill="white" font-weight="bold" font-size="12">A</text>
                            <text x="400" y="130" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Aman</text>
                            
                            <!-- Friend candidates -->
                            <circle cx="100" cy="100" r="18" class="person-node candidate" data-person="Neha"/>
                            <text x="100" y="105" text-anchor="middle" fill="white" font-weight="bold" font-size="11">N</text>
                            <text x="100" y="85" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Neha</text>
                            
                            <circle cx="150" cy="50" r="18" class="person-node candidate" data-person="Ravi"/>
                            <text x="150" y="55" text-anchor="middle" fill="white" font-weight="bold" font-size="11">R</text>
                            <text x="150" y="35" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Ravi</text>
                            
                            <circle cx="500" cy="100" r="18" class="person-node candidate" data-person="Simran"/>
                            <text x="500" y="105" text-anchor="middle" fill="white" font-weight="bold" font-size="11">S</text>
                            <text x="500" y="85" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Simran</text>
                            
                            <circle cx="450" cy="50" r="18" class="person-node candidate" data-person="Kiran"/>
                            <text x="450" y="55" text-anchor="middle" fill="white" font-weight="bold" font-size="11">K</text>
                            <text x="450" y="35" text-anchor="middle" fill="#1e293b" font-weight="bold" font-family="Georgia">Kiran</text>
                        </g>
                        
                        <!-- Legend -->
                        <g transform="translate(20, 380)">
                            <rect x="0" y="0" width="200" height="100" fill="rgba(254,247,237,0.95)" stroke="#3B82F6" rx="5"/>
                            <text x="5" y="15" font-weight="bold" font-size="12" font-family="Georgia">Legend:</text>
                            <circle cx="15" cy="30" r="8" fill="#3B82F6"/>
                            <text x="28" y="35" font-size="11" font-family="Georgia">Target User</text>
                            <circle cx="15" cy="45" r="6" fill="#10B981"/>
                            <text x="28" y="50" font-size="11" font-family="Georgia">Direct Friends</text>
                            <circle cx="15" cy="60" r="6" fill="#F59E0B"/>
                            <text x="28" y="65" font-size="11" font-family="Georgia">Candidates</text>
                            <circle cx="15" cy="75" r="6" fill="#EF4444"/>
                            <text x="28" y="80" font-size="11" font-family="Georgia">Evaluating</text>
                            <circle cx="120" cy="30" r="6" fill="#8B5CF6"/>
                            <text x="133" y="35" font-size="11" font-family="Georgia">Recommended</text>
                        </g>
                    </svg>
                    
                    <div class="user-profiles">
                        <div class="profile-card">
                            <h4>Rahul (Target)</h4>
                            <div class="profile-info">
                                📍 <strong>City:</strong> Delhi<br>
                                💻 <strong>Skills:</strong> Python, AI<br>
                                👥 <strong>Friends:</strong> Priya, Aman
                            </div>
                        </div>
                        <div class="profile-card">
                            <h4>Neha (Candidate)</h4>
                            <div class="profile-info">
                                📍 <strong>City:</strong> Delhi<br>
                                💻 <strong>Skills:</strong> Python, Web Tech<br>
                                👥 <strong>Friends:</strong> Priya
                            </div>
                        </div>
                        <div class="profile-card">
                            <h4>Ravi (Candidate)</h4>
                            <div class="profile-info">
                                📍 <strong>City:</strong> Pune<br>
                                💻 <strong>Skills:</strong> JavaScript, AI<br>
                                👥 <strong>Friends:</strong> Priya
                            </div>
                        </div>
                        <div class="profile-card">
                            <h4>Simran (Candidate)</h4>
                            <div class="profile-info">
                                📍 <strong>City:</strong> Mumbai<br>
                                💻 <strong>Skills:</strong> Embedded, Python<br>
                                👥 <strong>Friends:</strong> Aman
                            </div>
                        </div>
                        <div class="profile-card">
                            <h4>Kiran (Candidate)</h4>
                            <div class="profile-info">
                                📍 <strong>City:</strong> Delhi<br>
                                💻 <strong>Skills:</strong> AI, JavaScript<br>
                                👥 <strong>Friends:</strong> Aman
                            </div>
                        </div>
                    </div>
                    
                    <div class="scoring-display" id="scoringDisplay">
                        <h4>Candidate Evaluation Scores</h4>
                        <div id="scoreContent"></div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn" onclick="runFriendRecommendation()">🚀 Find Friend Recommendations</button>
                        <button class="btn" onclick="resetNetwork()">🔄 Reset</button>
                        <button class="btn" onclick="showScoring()">📊 Show Scoring Details</button>
                        <button class="btn" onclick="explainAlgorithm()">🧠 Explain Algorithm</button>
                    </div>
                    
                    <div class="step-info" id="stepInfo"></div>
                    <div class="result" id="result"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel right-panel">
            <div class="header">
                <h2>💻 Friend Recommendation Implementation</h2>
            </div>

            <div class="code-section">
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre># Import required library for advanced data structures (not used here but good practice)
from collections import defaultdict

# ========== STEP 1: BUILD THE SOCIAL NETWORK GRAPH ==========
# Dictionary representing friendship connections (bidirectional relationships)
# Key: Person's name, Value: List of their direct friends
graph = {
    'Rahul': ['Priya', 'Aman'],        # Rahul is friends with Priya and Aman
    'Priya': ['Rahul', 'Neha', 'Ravi'], # Priya knows Rahul + 2 others (Neha, Ravi)
    'Aman': ['Rahul', 'Simran', 'Kiran'], # Aman knows Rahul + 2 others (Simran, Kiran)
    'Neha': ['Priya'],                 # Neha only knows Priya (candidate for Rahul)
    'Ravi': ['Priya'],                 # Ravi only knows Priya (candidate for Rahul)
    'Simran': ['Aman'],                # Simran only knows Aman (candidate for Rahul)
    'Kiran': ['Aman']                  # Kiran only knows Aman (candidate for Rahul)
}

# ========== STEP 2: DEFINE USER LOCATIONS ==========
# Dictionary mapping each person to their city (geographic heuristic)
locations = {
    'Rahul': 'Delhi',     # Target user lives in Delhi
    'Priya': 'Delhi',     # Same city as Rahul (+5 bonus for any Delhi candidates)
    'Aman': 'Mumbai',     # Different city from Rahul
    'Neha': 'Delhi',      # Same city as Rahul (will get +5 points)
    'Ravi': 'Pune',       # Different city from Rahul (no location bonus)
    'Simran': 'Mumbai',   # Different city from Rahul (no location bonus)
    'Kiran': 'Delhi'      # Same city as Rahul (will get +5 points)
}

# ========== STEP 3: DEFINE TECHNICAL SKILLS ==========
# Dictionary mapping each person to their technical skills (professional heuristic)
interests = {
    'Rahul': ['Python', 'AI'],           # Target user's skills
    'Priya': ['Python', 'Web Tech'],     # Shares Python with Rahul
    'Aman': ['AI', 'JavaScript'],        # Shares AI with Rahul
    'Neha': ['Python', 'Web Tech'],      # Shares Python with Rahul (+2 points)
    'Ravi': ['JavaScript', 'AI'],        # Shares AI with Rahul (+2 points)
    'Simran': ['Embedded', 'Python'],    # Shares Python with Rahul (+2 points)
    'Kiran': ['AI', 'JavaScript']        # Shares AI with Rahul (+2 points)
}

# ========== STEP 4: HEURISTIC SCORING FUNCTION ==========
def calculate_friend_score(user, candidate):
    """
    Calculate friendship compatibility score using Best-First Search heuristic
    This is the core of our informed search algorithm
    Formula: Score = 10*(mutual friends) + 5*(same city) + 2*(common skills)
    """
    score = 0  # Initialize total friendship score
    
    # HEURISTIC 1: Mutual Friends Analysis (+10 points each)
    # Convert friend lists to sets for efficient intersection operation
    user_friends = set(graph.get(user, []))           # Rahul's friends: {'Priya', 'Aman'}
    candidate_friends = set(graph.get(candidate, [])) # e.g., Neha's friends: {'Priya'}
    mutual_friends = user_friends & candidate_friends # Find common friends using set intersection
    score += 10 * len(mutual_friends)                 # Each mutual friend adds 10 points
    
    # HEURISTIC 2: Geographic Proximity (+5 points)
    # Check if both users live in the same city
    if locations.get(user) == locations.get(candidate):
        score += 5  # Same city bonus (e.g., both in Delhi)
    
    # HEURISTIC 3: Technical Skill Compatibility (+2 points each)
    # Convert skill lists to sets and find common technical skills
    user_skills = set(interests.get(user, []))           # Rahul's skills: {'Python', 'AI'}
    candidate_skills = set(interests.get(candidate, [])) # e.g., Neha's skills: {'Python', 'Web Tech'}
    common_skills = user_skills & candidate_skills      # Common skills: {'Python'}
    score += 2 * len(common_skills)                     # Each common skill adds 2 points
    
    # Return total score and detailed breakdown for analysis
    return score, mutual_friends, common_skills

# ========== STEP 5: BEST-FIRST SEARCH ALGORITHM ==========
def recommend_friends(target_user):
    """
    Implement Best-First Search for friend recommendations
    Key principle: Always evaluate the most promising candidates first
    """
    print(f"🎯 Finding friend recommendations for {target_user}")
    print("=" * 50)
    
    # Initialize data structures for search algorithm
    visited_candidates = set()    # Track candidates we've already evaluated
    friend_candidates = []        # Store (score, person, details) tuples
    
    # Get target user's existing social circle
    current_friends = set(graph.get(target_user, []))  # Rahul's current friends
    print(f"Current friends: {', '.join(current_friends)}")
    print()
    
    # ========== EXPLORATION PHASE: Find Friends-of-Friends ==========
    # This implements the "expand node" step in Best-First Search
    for friend in current_friends:  # For each of Rahul's friends (Priya, Aman)
        print(f"🔍 Exploring {friend}'s connections...")
        
        # Look at each connection of the current friend
        for potential_friend in graph.get(friend, []):
            # Apply filtering rules to avoid invalid recommendations
            if (potential_friend != target_user and           # Don't recommend user to themselves
                potential_friend not in current_friends and   # Don't recommend existing friends
                potential_friend not in visited_candidates):  # Don't evaluate same person twice
                
                # ========== HEURISTIC EVALUATION ==========
                # This is where Best-First Search uses domain knowledge
                score, mutual, common_skills = calculate_friend_score(
                    target_user, potential_friend
                )
                
                # Store candidate with their score and supporting data
                friend_candidates.append((score, potential_friend, mutual, common_skills))
                visited_candidates.add(potential_friend)  # Mark as evaluated
                
                # Display evaluation details for learning purposes
                print(f"  → {potential_friend}: Score = {score}")
                print(f"    Mutual friends: {list(mutual)}")
                print(f"    Common skills: {list(common_skills)}")
                print(f"    Same city: {locations[target_user] == locations[potential_friend]}")
                print()
    
    # ========== BEST-FIRST SELECTION ==========
    # Sort candidates by score in descending order (highest score first)
    # This is the "greedy" aspect - always pick the best option available
    friend_candidates.sort(reverse=True, key=lambda x: x[0])  # Sort by score (index 0)
    
    print("🏆 FRIEND RECOMMENDATIONS (Best-First Order):")
    print("=" * 50)
    
    # Display sorted recommendations with detailed breakdown
    for i, (score, person, mutual, common_skills) in enumerate(friend_candidates, 1):
        print(f"{i}. {person} (Score: {score})")                    # Rank and total score
        print(f"   📍 City: {locations[person]}")                   # Geographic info
        print(f"   💻 Skills: {', '.join(interests[person])}")      # Technical skills
        print(f"   👥 Mutual friends: {', '.join(mutual) if mutual else 'None'}")        # Social connections
        print(f"   🎯 Common skills: {', '.join(common_skills) if common_skills else 'None'}")  # Skill overlap
        print()
    
    return friend_candidates  # Return sorted list for further processing

# ========== STEP 6: EXECUTE THE RECOMMENDATION SYSTEM ==========
if __name__ == "__main__":
    # Run the Best-First Search algorithm for Rahul
    recommendations = recommend_friends('Rahul')
    
    # Display final summary statistics
    print("✨ SUMMARY:")
    print(f"Found {len(recommendations)} potential friends")
    
    # Highlight the best recommendation (highest scoring candidate)
    if recommendations:
        best_match = recommendations[0]  # First item after sorting = highest score
        print(f"Best recommendation: {best_match[1]} with score {best_match[0]}")
        
        # Expected result: Neha should score highest with:
        # - Mutual friend Priya: +10 points
        # - Same city (Delhi): +5 points  
        # - Common skill (Python): +2 points
        # - Total: 17 points
</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Social network data
        const socialGraph = {
            'Rahul': ['Priya', 'Aman'],
            'Priya': ['Rahul', 'Neha', 'Ravi'],
            'Aman': ['Rahul', 'Simran', 'Kiran'],
            'Neha': ['Priya'],
            'Ravi': ['Priya'],
            'Simran': ['Aman'],
            'Kiran': ['Aman']
        };

        const locations = {
            'Rahul': 'Delhi',
            'Priya': 'Delhi',
            'Aman': 'Mumbai',
            'Neha': 'Delhi',
            'Ravi': 'Pune',
            'Simran': 'Mumbai',
            'Kiran': 'Delhi'
        };

        const interests = {
            'Rahul': ['Python', 'AI'],
            'Priya': ['Python', 'Web Tech'],
            'Aman': ['AI', 'JavaScript'],
            'Neha': ['Python', 'Web Tech'],
            'Ravi': ['JavaScript', 'AI'],
            'Simran': ['Embedded', 'Python'],
            'Kiran': ['AI', 'JavaScript']
        };

        let isSearching = false;

        function calculateFriendScore(user, candidate) {
            let score = 0;
            let details = {
                mutualFriends: [],
                sameCity: false,
                commonInterests: []
            };

            // Mutual friends: +10 each
            const userFriends = new Set(socialGraph[user] || []);
            const candidateFriends = new Set(socialGraph[candidate] || []);
            const mutualFriends = [...userFriends].filter(x => candidateFriends.has(x));
            score += 10 * mutualFriends.length;
            details.mutualFriends = mutualFriends;

            // Same city: +5
            if (locations[user] === locations[candidate]) {
                score += 5;
                details.sameCity = true;
            }

            // Common interests: +2 each
            const userInterests = new Set(interests[user] || []);
            const candidateInterests = new Set(interests[candidate] || []);
            const commonInterests = [...userInterests].filter(x => candidateInterests.has(x));
            score += 2 * commonInterests.length;
            details.commonInterests = commonInterests;

            return { score, details };
        }

        function resetNetwork() {
            document.querySelectorAll('.person-node').forEach(node => {
                const person = node.dataset.person;
                if (person === 'Rahul') {
                    node.className = 'person-node target';
                } else if (['Priya', 'Aman'].includes(person)) {
                    node.className = 'person-node friend';
                } else {
                    node.className = 'person-node candidate';
                }
            });

            document.querySelectorAll('.connection').forEach(conn => {
                conn.className = 'connection';
            });

            document.getElementById('stepInfo').style.display = 'none';
            document.getElementById('result').style.display = 'none';
            document.getElementById('scoringDisplay').style.display = 'none';
        }

        function updateStep(message) {
            const stepInfo = document.getElementById('stepInfo');
            stepInfo.style.display = 'block';
            stepInfo.innerHTML += message + '<br>';
            stepInfo.scrollTop = stepInfo.scrollHeight;
        }

        function highlightPerson(person, className) {
            const personEl = document.querySelector(`[data-person="${person}"]`);
            if (personEl) {
                personEl.className = `person-node ${className}`;
            }
        }

        function highlightConnection(from, to, className) {
            const connection = document.querySelector(`[data-from="${from}"][data-to="${to}"]`) ||
                             document.querySelector(`[data-from="${to}"][data-to="${from}"]`);
            if (connection) {
                connection.className = `connection ${className}`;
            }
        }

        async function runFriendRecommendation() {
            if (isSearching) return;
            isSearching = true;

            resetNetwork();
            document.getElementById('stepInfo').innerHTML = '';
            
            updateStep('🚀 Starting Best-First Search Friend Recommendation');
            updateStep('Target User: Rahul');
            updateStep('Heuristic: 10×(Mutual Friends) + 5×(Same City) + 2×(Common Skills)');
            updateStep('');

            const targetUser = 'Rahul';
            const currentFriends = new Set(socialGraph[targetUser]);
            const visitedCandidates = new Set();
            const friendCandidates = [];

            updateStep(`📋 Current friends: ${Array.from(currentFriends).join(', ')}`);
            updateStep('');

            // Explore friends-of-friends
            for (const friend of currentFriends) {
                updateStep(`🔍 Exploring ${friend}'s connections...`);
                highlightPerson(friend, 'evaluating');
                highlightConnection('Rahul', friend, 'active');
                
                await new Promise(resolve => setTimeout(resolve, 1000));

                for (const potentialFriend of socialGraph[friend] || []) {
                    if (potentialFriend !== targetUser && 
                        !currentFriends.has(potentialFriend) && 
                        !visitedCandidates.has(potentialFriend)) {
                        
                        updateStep(`  → Evaluating ${potentialFriend}...`);
                        highlightPerson(potentialFriend, 'evaluating');
                        highlightConnection(friend, potentialFriend, 'mutual');
                        
                        await new Promise(resolve => setTimeout(resolve, 800));

                        const { score, details } = calculateFriendScore(targetUser, potentialFriend);
                        friendCandidates.push({ 
                            person: potentialFriend, 
                            score, 
                            details,
                            throughFriend: friend
                        });
                        visitedCandidates.add(potentialFriend);

                        updateStep(`    Score: ${score} points`);
                        updateStep(`    Mutual friends: ${details.mutualFriends.join(', ') || 'None'} (+${details.mutualFriends.length * 10})`);
                        updateStep(`    Same city: ${details.sameCity ? 'Yes' : 'No'} (+${details.sameCity ? 5 : 0})`);
                        updateStep(`    Common skills: ${details.commonInterests.join(', ') || 'None'} (+${details.commonInterests.length * 2})`);
                        updateStep('');

                        highlightPerson(potentialFriend, 'candidate');
                    }
                }

                highlightPerson(friend, 'friend');
                highlightConnection('Rahul', friend, 'connection');
            }

            // Sort by score (Best-First)
            friendCandidates.sort((a, b) => b.score - a.score);

            updateStep('🏆 FRIEND RECOMMENDATIONS (Best-First Order):');
            updateStep('');

            let resultHTML = '<h3>🎯 Friend Recommendations for Rahul</h3>';
            
            friendCandidates.forEach((candidate, index) => {
                const rank = index + 1;
                updateStep(`${rank}. ${candidate.person} (Score: ${candidate.score})`);
                updateStep(`   📍 City: ${locations[candidate.person]}`);
                updateStep(`   💻 Skills: ${interests[candidate.person].join(', ')}`);
                updateStep(`   👥 Connected through: ${candidate.throughFriend}`);
                updateStep('');

                if (index === 0) {
                    highlightPerson(candidate.person, 'recommended');
                }

                resultHTML += `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <strong>${rank}. ${candidate.person}</strong> - Score: ${candidate.score}<br>
                        📍 ${locations[candidate.person]} | 
                        💻 ${interests[candidate.person].join(', ')}<br>
                        👥 Through: ${candidate.throughFriend}
                    </div>
                `;
            });

            if (friendCandidates.length > 0) {
                const bestMatch = friendCandidates[0];
                updateStep(`✅ Best recommendation: ${bestMatch.person} with ${bestMatch.score} points`);
                
                resultHTML += `<p style="margin-top: 20px;"><strong>🎯 Top Recommendation: ${bestMatch.person}</strong></p>`;
            }

            document.getElementById('result').innerHTML = resultHTML;
            document.getElementById('result').style.display = 'block';

            isSearching = false;
        }

        function showScoring() {
            const scoringDisplay = document.getElementById('scoringDisplay');
            const scoreContent = document.getElementById('scoreContent');
            
            scoringDisplay.style.display = 'block';
            scoreContent.innerHTML = '';

            const candidates = ['Neha', 'Ravi', 'Simran', 'Kiran'];
            
            candidates.forEach(candidate => {
                const { score, details } = calculateFriendScore('Rahul', candidate);
                
                const item = document.createElement('div');
                item.innerHTML = `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <strong>${candidate}: ${score} points</strong><br>
                        <small>
                            • Mutual friends: ${details.mutualFriends.join(', ') || 'None'} (+${details.mutualFriends.length * 10})<br>
                            • Same city: ${details.sameCity ? 'Yes' : 'No'} (+${details.sameCity ? 5 : 0})<br>
                            • Common skills: ${details.commonInterests.join(', ') || 'None'} (+${details.commonInterests.length * 2})
                        </small>
                    </div>
                `;
                scoreContent.appendChild(item);
            });
        }

        function explainAlgorithm() {
            const stepInfo = document.getElementById('stepInfo');
            stepInfo.style.display = 'block';
            stepInfo.innerHTML = `
                🧠 Best-First Search Algorithm for Friend Recommendations:<br><br>
                <strong>1. Initialization:</strong><br>
                   - Start with target user (Rahul)<br>
                   - Identify current friends (Priya, Aman)<br><br>
                <strong>2. Exploration Phase:</strong><br>
                   - For each current friend, explore their connections<br>
                   - Find friends-of-friends (second-degree connections)<br>
                   - Skip users who are already friends or the target user<br><br>
                <strong>3. Heuristic Evaluation:</strong><br>
                   - Calculate score for each candidate using formula:<br>
                   - Score = 10×(Mutual Friends) + 5×(Same City) + 2×(Common Skills)<br><br>
                <strong>4. Best-First Selection:</strong><br>
                   - Sort all candidates by score (highest first)<br>
                   - This greedy approach prioritizes most promising candidates<br><br>
                <strong>5. Recommendation Output:</strong><br>
                   - Present ranked list of friend suggestions<br>
                   - Higher scores indicate better potential friendships<br><br>
                🎯 <strong>Key Insight:</strong> Best-First Search uses domain knowledge (social data) to make intelligent decisions, unlike blind search algorithms that explore randomly!
            `;
        }

        function copyCode(button) {
            const code = button.nextElementSibling.textContent;
            navigator.clipboard.writeText(code).then(() => {
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = 'Copy', 2000);
            });
        }
    </script>
</body>
</html>

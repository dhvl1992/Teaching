<!DOCTYPE html>
<html lang="en">
<head>
  <title>Alpha-Beta Pruning with Visual Connectors</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; box-sizing:border-box;}
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #F1F5F9;
      text-align: center;
    }
    .orientation-tip {
      display: none;
      background: #fff6d3;
      color: #ad6b04;
      padding: 10px 0;
      font-weight: bold;
      font-size: 1.02rem;
      letter-spacing: .02em;
      border-bottom: 2px solid #fde68a;
    }
    .container {
      max-width: 660px;
      margin: auto;
      padding: 0 8px;
    }
    h2 {
      font-size: 1.22rem;
      font-weight: bold;
      margin: 18px 0 6px 0;
      color: #1e293b;
    }
    .desc {
      background: #fffbe8;
      color: #4b5563;
      border-radius: 10px;
      padding: 12px 10px;
      margin: 14px auto 8px auto;
      font-size: 1.05rem;
      min-height: 46px;
      max-width: 480px;
      box-shadow: 0 2px 8px #e5e7eb;
      word-break: break-word;
    }
    .tree-wrap { position: relative; margin: 0 auto 10px auto; }
    .tree {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px 0 0 0;
      width: 100%;
      z-index: 1;
      position: relative;
    }
    .level {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      margin: 14px 0 0 0;
      width: 100%;
      gap: 14px;
      position: relative;
      z-index: 1;
    }
    /* New: special centering for root node */
    .root-level {
      justify-content: center !important;
      gap: 0 !important;
      margin-bottom: 0 !important;
    }
    .root-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .node {
      border: 2.2px solid #3B82F6;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      font-weight: 600;
      font-size: 18px;
      margin: 0 4px;
      position: relative;
      transition: background 0.4s, border-color 0.4s;
      box-shadow: 0 2px 6px #e0e7ef77;
      z-index: 2;
    }
    .highlight { background: #FFF6D3 !important; border-color: #F59E42 !important; }
    .pruned    { background: #E5E7EB !important; border-color: #D1D5DB !important; color: #aaa !important; }
    .max { color: #2563EB; }
    .min { color: #DC2626; }
    .ab-labels {
      display: flex; justify-content: center; gap: 6px;
      margin-top: 2px;
    }
    .ab-badge {
      display: inline-block; padding: 2px 6px 2px 6px;
      border-radius: 7px; font-size: 11.5px; font-weight: 500;
      margin: 0 2px; line-height: 1.2;
    }
    .ab-alpha { background: #e0e7ff; color: #2563eb; border: 1.2px solid #b5bcf7;}
    .ab-beta  { background: #fee2e2; color: #dc2626; border: 1.2px solid #fca5a5;}
    .buttons {
      display: flex; justify-content: center; gap: 20px; margin: 16px 0 10px 0;
      flex-wrap: wrap;
    }
    .btn {
      padding: 13px 24px;
      font-size: 17px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, #6366F1 0%, #3B82F6 100%);
      color: #fff;
      box-shadow: 0 2px 8px #dbeafe88;
      cursor: pointer;
      margin-bottom: 8px;
      transition: background 0.2s, transform 0.2s;
      outline: none;
      min-width: 120px;
    }
    .btn:active { background: #312e81; transform: scale(.97);}
    .btn:disabled { opacity: 0.55; background: #94a3b8; cursor: not-allowed;}
    /* SVG lines (tree connectors) */
    #svgLines {
      position: absolute;
      pointer-events: none;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    @media (max-width: 560px) {
      .container { max-width: 99vw; }
      .desc { font-size: 0.98rem; min-height: 32px;}
      .node { font-size: 15px; width: 34px; height: 34px;}
      .ab-badge { font-size: 9.3px; padding: 2px 4px;}
      .btn { font-size: 14px; min-width: 95px; padding: 10px 8px;}
      .tree-wrap { min-width: 310px;}
    }
    @media (max-width: 380px) {
      .ab-badge { font-size: 8.3px; padding: 1px 3px;}
      .node { width: 28px; height: 28px;}
    }
  </style>
</head>
<body>
  <div class="orientation-tip" id="orientTip">
    For best visibility, please rotate your phone to landscape.
  </div>
  <div class="container">
    <h2>Alpha-Beta Pruning – 4-Level Demo</h2>
    <div class="desc" id="desc"></div>
    <div class="tree-wrap">
      <svg id="svgLines"></svg>
      <div class="tree" id="tree"></div>
    </div>
    <div class="buttons">
      <button class="btn" id="nextBtn">Next Step</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>
  <script>
    // 4-level tree for pruning
    const treeData = {
      type: 'max', value: null, alpha: null, beta: null, children: [
        {
          type: 'min', value: null, alpha: null, beta: null, children: [
            {
              type: 'max', value: null, alpha: null, beta: null, children: [
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 3, children: [] },
                  { type: null, value: 12, children: [] }
                ]},
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 8, children: [] },
                  { type: null, value: 2, children: [] }
                ]}
              ]
            },
            {
              type: 'max', value: null, alpha: null, beta: null, children: [
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 14, children: [] },
                  { type: null, value: 5, children: [] }
                ]},
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 2, children: [] },
                  { type: null, value: 4, children: [] }
                ]}
              ]
            }
          ]
        },
        {
          type: 'min', value: null, alpha: null, beta: null, children: [
            {
              type: 'max', value: null, alpha: null, beta: null, children: [
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 5, children: [] },
                  { type: null, value: 2, children: [] }
                ]},
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 4, children: [] },
                  { type: null, value: 6, children: [] }
                ]}
              ]
            },
            {
              type: 'max', value: null, alpha: null, beta: null, children: [
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 6, children: [] },
                  { type: null, value: 10, children: [] }
                ]},
                { type: 'min', value: null, alpha: null, beta: null, children: [
                  { type: null, value: 8, children: [] },
                  { type: null, value: 11, children: [] }
                ]}
              ]
            }
          ]
        }
      ]
    };

    let visitState = null, highlights = [], stepper = null;

    function buildState(node) {
      const st = {visited:false,pruned:false,children:[]};
      node.children.forEach((child, i) => st.children[i] = buildState(child));
      return st;
    }

    function* alphabetaStep(node, state, alpha, beta, path = [], isMax = true) {
      if (!node.children.length) {
        state.visited = true; highlights = [path];
        yield {desc: `Reached leaf node: value = ${node.value}`, highlights: [path]};
        return node.value;
      }
      let bestVal = isMax ? -Infinity : Infinity;
      node.alpha = alpha; node.beta = beta;
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i], childState = state.children[i];
        highlights = [path.concat([i])];
        yield {desc: `${isMax?'MAX':'MIN'} node at depth ${path.length}: evaluating child ${i+1}/${node.children.length} (α=${alpha}, β=${beta})`, highlights:[path.concat([i])]};
        let val = yield* alphabetaStep(child, childState, alpha, beta, path.concat([i]), child.type === 'max');
        if (isMax) { if (val > bestVal) bestVal = val; if (val > alpha) alpha = val; }
        else { if (val < bestVal) bestVal = val; if (val < beta) beta = val; }
        node.alpha = alpha; node.beta = beta;
        if (beta <= alpha) {
          for (let j = i+1; j < node.children.length; j++) state.children[j].pruned = true;
          yield {desc: `Pruning remaining ${node.children.length-i-1} branch(es) at this ${isMax?'MAX':'MIN'} node (β ≤ α)!`, highlights:[path]};
          break;
        }
      }
      node.value = bestVal; state.visited = true;
      highlights = [path];
      yield {desc: `${isMax?'MAX':'MIN'} node at depth ${path.length}: back up value = ${bestVal}`, highlights:[path]};
      return bestVal;
    }

    function getLevels(node, state, depth = 0, levels = [], slevels = []) {
      if (!levels[depth]) { levels[depth] = []; slevels[depth] = []; }
      levels[depth].push(node); slevels[depth].push(state);
      node.children.forEach((child, i) => getLevels(child, state.children[i], depth + 1, levels, slevels));
      return [levels, slevels];
    }

    function renderTree() {
      const treeDiv = document.getElementById('tree');
      treeDiv.innerHTML = '';
      const [levels, slevels] = getLevels(treeData, visitState);

      // Draw SVG lines (tree connectors)
      setTimeout(() => drawSVGLines(levels, slevels), 10);

      levels.forEach((level, d) => {
        let levelDiv;
        if (d === 0) {
          // Special centering for root node
          levelDiv = document.createElement('div');
          levelDiv.className = 'level root-level';
          const rootWrap = document.createElement('div');
          rootWrap.className = 'root-wrap';
          // Root node
          const div = document.createElement('div');
          div.className = 'node';
          let state = slevels[d][0];
          if (level[0].type === 'max') div.classList.add('max');
          if (level[0].type === 'min') div.classList.add('min');
          if (state.pruned) div.classList.add('pruned');
          if (highlights.some(path => path.length === 0 && visitState === state))
            div.classList.add('highlight');
          div.innerText = level[0].value!==null ? level[0].value : level[0].type ? level[0].type.toUpperCase() : '?';

          rootWrap.appendChild(div);

          // α/β badges (centered below root)
          if (level[0].children && level[0].children.length && !state.pruned) {
            const abDiv = document.createElement('div');
            abDiv.className = 'ab-labels';
            if (level[0].alpha !== null)
                abDiv.innerHTML += `<span class="ab-badge ab-alpha">α: ${level[0].alpha === -Infinity ? '−∞' : level[0].alpha}</span>`;
            if (level[0].beta !== null)
                abDiv.innerHTML += `<span class="ab-badge ab-beta">β: ${level[0].beta === Infinity ? '+∞' : level[0].beta}</span>`;
            abDiv.style.marginBottom = '10px';
            rootWrap.appendChild(abDiv);
          }
          levelDiv.appendChild(rootWrap);
        } else {
          // Standard levels
          levelDiv = document.createElement('div');
          levelDiv.className = 'level';
          level.forEach((node, i) => {
            const div = document.createElement('div');
            div.className = 'node';
            let state = slevels[d][i];
            if (node.type === 'max') div.classList.add('max');
            if (node.type === 'min') div.classList.add('min');
            if (state.pruned) div.classList.add('pruned');
            if (highlights.some(path => {
              if (path.length !== d) return false;
              let idxs = path.slice(), idx = idxs.pop(), ref = visitState;
              for (let dd = 0; dd < d-1; dd++) { if (!ref.children[idxs[dd]]) return false; ref = ref.children[idxs[dd]]; }
              return ref.children && ref.children[idx] === state;
            })) div.classList.add('highlight');
            div.innerText = node.value!==null ? node.value : node.type ? node.type.toUpperCase() : '?';

            // α/β badges
            if (node.children && node.children.length && !state.pruned) {
              const abDiv = document.createElement('div');
              abDiv.className = 'ab-labels';
              if (node.alpha !== null)
                  abDiv.innerHTML += `<span class="ab-badge ab-alpha">α: ${node.alpha === -Infinity ? '−∞' : node.alpha}</span>`;
              if (node.beta !== null)
                  abDiv.innerHTML += `<span class="ab-badge ab-beta">β: ${node.beta === Infinity ? '+∞' : node.beta}</span>`;
              div.appendChild(abDiv);
            }
            levelDiv.appendChild(div);
          });
        }
        treeDiv.appendChild(levelDiv);
      });
    }

    function drawSVGLines(levels, slevels) {
      const svg = document.getElementById('svgLines');
      svg.innerHTML = '';
      // Find all .node elements and their positions
      const allNodes = Array.from(document.querySelectorAll('.tree .node'));
      let offset = 0;
      let prevRowCount = 0;
      let nodeCenters = [];
      levels.forEach((level, d) => {
        let levelCenters = [];
        let levelNodes = allNodes.slice(offset, offset + level.length);
        levelNodes.forEach(nodeEl => {
          const rect = nodeEl.getBoundingClientRect();
          const parentRect = svg.getBoundingClientRect();
          levelCenters.push({
            x: rect.left - parentRect.left + rect.width/2,
            y: rect.top - parentRect.top + rect.height/2
          });
        });
        nodeCenters.push(levelCenters);
        offset += level.length;
      });
      // For each parent-child, draw line
      for (let d = 0; d < nodeCenters.length-1; d++) {
        let parentLevel = nodeCenters[d], childLevel = nodeCenters[d+1];
        let pi = 0;
        levels[d].forEach((parent, i) => {
          let state = slevels[d][i];
          if (state.pruned) return; // Don't connect from pruned parent
          let children = parent.children || [];
          for (let j = 0; j < children.length; j++) {
            let ci = pi;
            let childState = slevels[d+1][ci];
            pi++;
            if (childState.pruned) continue;
            // Draw line
            let line = document.createElementNS("http://www.w3.org/2000/svg","line");
            line.setAttribute('x1', parentLevel[i].x);
            line.setAttribute('y1', parentLevel[i].y+18);
            line.setAttribute('x2', childLevel[ci].x);
            line.setAttribute('y2', childLevel[ci].y-18);
            line.setAttribute('stroke', "#b6b6b6");
            line.setAttribute('stroke-width', "2");
            svg.appendChild(line);
          }
        });
      }
    }

    function nextStep() {
      let {value, done} = stepper.next();
      renderTree();
      document.getElementById('desc').innerText = value ? value.desc : '';
      if (done) {
        document.getElementById('nextBtn').disabled = true;
        document.getElementById('desc').innerText += `\n\nAlpha-Beta Complete! Root value: ${treeData.value}`;
      }
    }

    function restart() {
      visitState = buildState(treeData);
      highlights = [];
      treeData.value = null; treeData.alpha = null; treeData.beta = null;
      treeData.children.forEach(child => {
        child.value = null; child.alpha = null; child.beta = null;
        child.children.forEach(c2 => {
          c2.value = null; c2.alpha = null; c2.beta = null;
          c2.children.forEach(c3 => {
            c3.value = null; c3.alpha = null; c3.beta = null;
          });
        });
      });
      stepper = alphabetaStep(treeData, visitState, -Infinity, Infinity, [], true);
      document.getElementById('nextBtn').disabled = false;
      nextStep();
    }


    // Mobile orientation tip
    function showOrientationTip() {
      const orientTip = document.getElementById('orientTip');
      if (window.matchMedia("(max-width: 600px)").matches) {
        if (window.matchMedia("(orientation: portrait)").matches) {
          orientTip.style.display = "block";
        } else {
          orientTip.style.display = "none";
        }
      } else {
        orientTip.style.display = "none";
      }
    }
    window.addEventListener("resize", showOrientationTip);
    window.addEventListener("orientationchange", () => { setTimeout(showOrientationTip, 150); setTimeout(renderTree, 200); });
    document.getElementById('nextBtn').onclick = nextStep;
    document.getElementById('resetBtn').onclick = restart;
    showOrientationTip();
    restart();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Minimax Algorithm – 3-Level Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; box-sizing:border-box;}
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #F1F5F9;
      text-align: center;
    }
    .orientation-tip {
      display: none;
      background: #fff6d3;
      color: #ad6b04;
      padding: 10px 0;
      font-weight: bold;
      font-size: 1.02rem;
      letter-spacing: .02em;
      border-bottom: 2px solid #fde68a;
    }
    .container {
      max-width: 660px;
      margin: auto;
      padding: 0 8px;
    }
    h2 {
      font-size: 1.22rem;
      font-weight: bold;
      margin: 18px 0 6px 0;
      color: #1e293b;
    }
    .desc {
      background: #fffbe8;
      color: #4b5563;
      border-radius: 10px;
      padding: 12px 10px;
      margin: 14px auto 8px auto;
      font-size: 1.05rem;
      min-height: 46px;
      max-width: 480px;
      box-shadow: 0 2px 8px #e5e7eb;
      word-break: break-word;
    }
    .tree-wrap { position: relative; margin: 0 auto 10px auto; }
    .tree {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px 0 0 0;
      width: 100%;
      z-index: 1;
      position: relative;
    }
    .level {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      margin: 14px 0 0 0;
      width: 100%;
      gap: 14px;
      position: relative;
      z-index: 1;
    }
    .root-level {
      justify-content: center !important;
      gap: 0 !important;
      margin-bottom: 0 !important;
    }
    .root-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .node {
      border: 2.2px solid #3B82F6;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      font-weight: 600;
      font-size: 18px;
      margin: 0 4px;
      position: relative;
      transition: background 0.4s, border-color 0.4s;
      box-shadow: 0 2px 6px #e0e7ef77;
      z-index: 2;
    }
    .highlight { background: #A7F3D0 !important; border-color: #059669 !important; }
    .max { color: #2563EB; }
    .min { color: #DC2626; }
    .pruned { background: #E5E7EB !important; border-color: #D1D5DB !important; color: #aaa !important; }
    .buttons {
      display: flex; justify-content: center; gap: 20px; margin: 16px 0 10px 0;
      flex-wrap: wrap;
    }
    .btn {
      padding: 13px 24px;
      font-size: 17px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, #6366F1 0%, #3B82F6 100%);
      color: #fff;
      box-shadow: 0 2px 8px #dbeafe88;
      cursor: pointer;
      margin-bottom: 8px;
      transition: background 0.2s, transform 0.2s;
      outline: none;
      min-width: 120px;
    }
    .btn:active { background: #312e81; transform: scale(.97);}
    .btn:disabled { opacity: 0.55; background: #94a3b8; cursor: not-allowed;}
    #svgLines {
      position: absolute;
      pointer-events: none;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    @media (max-width: 560px) {
      .container { max-width: 99vw; }
      .desc { font-size: 0.98rem; min-height: 32px;}
      .node { font-size: 15px; width: 34px; height: 34px;}
      .btn { font-size: 14px; min-width: 95px; padding: 10px 8px;}
      .tree-wrap { min-width: 310px;}
    }
    @media (max-width: 380px) {
      .node { width: 28px; height: 28px;}
    }
  </style>
</head>
<body>
  <div class="orientation-tip" id="orientTip">
    For best visibility, please rotate your phone to landscape.
  </div>
  <div class="container">
    <h2>Minimax Algorithm – 3-Level Demo</h2>
    <div class="desc" id="desc"></div>
    <div class="tree-wrap">
      <svg id="svgLines"></svg>
      <div class="tree" id="tree"></div>
    </div>
    <div class="buttons">
      <button class="btn" id="nextBtn">Next Step</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>
  <script>
    // 3-level tree for Minimax
    const treeData = {
      type: 'max', value: null, children: [
        {
          type: 'min', value: null, children: [
            { type: null, value: 3, children: [] },
            { type: null, value: 5, children: [] },
            { type: null, value: 2, children: [] }
          ]
        },
        {
          type: 'min', value: null, children: [
            { type: null, value: 9, children: [] },
            { type: null, value: 12, children: [] },
            { type: null, value: 5, children: [] }
          ]
        },
        {
          type: 'min', value: null, children: [
            { type: null, value: 14, children: [] },
            { type: null, value: 2, children: [] },
            { type: null, value: 8, children: [] }
          ]
        }
      ]
    };

    // State for highlighting/stepping
    let highlights = [], stepper = null, visitState = null;

    // Build visit state tree (for highlights)
    function buildState(node) {
      const st = {visited:false, children:[]};
      node.children.forEach((child, i) => st.children[i] = buildState(child));
      return st;
    }

    // Minimax algorithm, step-by-step, generator
    function* minimaxStep(node, state, path = [], isMax = true) {
      if (!node.children.length) {
        state.visited = true; highlights = [path];
        yield {desc: `Reached leaf node: value = ${node.value}`, highlights: [path]};
        return node.value;
      }
      let bestVal = isMax ? -Infinity : Infinity;
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i], childState = state.children[i];
        highlights = [path.concat([i])];
        yield {desc: `${isMax?'MAX':'MIN'} node at depth ${path.length}: evaluating child ${i+1}/${node.children.length}`, highlights:[path.concat([i])]};
        let val = yield* minimaxStep(child, childState, path.concat([i]), !isMax);
        if (isMax) { if (val > bestVal) bestVal = val; }
        else { if (val < bestVal) bestVal = val; }
      }
      node.value = bestVal; state.visited = true;
      highlights = [path];
      yield {desc: `${isMax?'MAX':'MIN'} node at depth ${path.length}: back up value = ${bestVal}`, highlights:[path]};
      return bestVal;
    }

    // Utility: get levels for rendering (same as in Alpha-Beta)
    function getLevels(node, state, depth = 0, levels = [], slevels = []) {
      if (!levels[depth]) { levels[depth] = []; slevels[depth] = []; }
      levels[depth].push(node); slevels[depth].push(state);
      node.children.forEach((child, i) => getLevels(child, state.children[i], depth + 1, levels, slevels));
      return [levels, slevels];
    }

    // Tree rendering with SVG edges and highlights
    function renderTree() {
      const treeDiv = document.getElementById('tree');
      treeDiv.innerHTML = '';
      const [levels, slevels] = getLevels(treeData, visitState);

      // Draw SVG lines (tree connectors)
      setTimeout(() => drawSVGLines(levels, slevels), 10);

      levels.forEach((level, d) => {
        let levelDiv;
        if (d === 0) {
          // Center root node
          levelDiv = document.createElement('div');
          levelDiv.className = 'level root-level';
          const rootWrap = document.createElement('div');
          rootWrap.className = 'root-wrap';
          // Root node
          const div = document.createElement('div');
          div.className = 'node';
          let state = slevels[d][0];
          if (level[0].type === 'max') div.classList.add('max');
          if (level[0].type === 'min') div.classList.add('min');
          if (state.visited) div.classList.add('highlight');
          div.innerText = level[0].value!==null ? level[0].value : level[0].type ? level[0].type.toUpperCase() : '?';
          rootWrap.appendChild(div);
          levelDiv.appendChild(rootWrap);
        } else {
          // Standard levels
          levelDiv = document.createElement('div');
          levelDiv.className = 'level';
          level.forEach((node, i) => {
            const div = document.createElement('div');
            div.className = 'node';
            let state = slevels[d][i];
            if (node.type === 'max') div.classList.add('max');
            if (node.type === 'min') div.classList.add('min');
            if (state.visited) div.classList.add('highlight');
            // Path-based highlight for animation
            if (highlights.some(path => {
              if (path.length !== d) return false;
              let idxs = path.slice(), idx = idxs.pop(), ref = visitState;
              for (let dd = 0; dd < d-1; dd++) { if (!ref.children[idxs[dd]]) return false; ref = ref.children[idxs[dd]]; }
              return ref.children && ref.children[idx] === state;
            })) div.classList.add('highlight');
            div.innerText = node.value!==null ? node.value : node.type ? node.type.toUpperCase() : '?';
            levelDiv.appendChild(div);
          });
        }
        treeDiv.appendChild(levelDiv);
      });
    }

    function drawSVGLines(levels, slevels) {
      const svg = document.getElementById('svgLines');
      svg.innerHTML = '';
      // Find all .node elements and their positions
      const allNodes = Array.from(document.querySelectorAll('.tree .node'));
      let offset = 0;
      let nodeCenters = [];
      levels.forEach((level, d) => {
        let levelCenters = [];
        let levelNodes = allNodes.slice(offset, offset + level.length);
        levelNodes.forEach(nodeEl => {
          const rect = nodeEl.getBoundingClientRect();
          const parentRect = svg.getBoundingClientRect();
          levelCenters.push({
            x: rect.left - parentRect.left + rect.width/2,
            y: rect.top - parentRect.top + rect.height/2
          });
        });
        nodeCenters.push(levelCenters);
        offset += level.length;
      });
      // For each parent-child, draw line
      for (let d = 0; d < nodeCenters.length-1; d++) {
        let parentLevel = nodeCenters[d], childLevel = nodeCenters[d+1];
        let pi = 0;
        levels[d].forEach((parent, i) => {
          let state = slevels[d][i];
          let children = parent.children || [];
          for (let j = 0; j < children.length; j++) {
            let ci = pi;
            let childState = slevels[d+1][ci];
            pi++;
            // Draw line
            let line = document.createElementNS("http://www.w3.org/2000/svg","line");
            line.setAttribute('x1', parentLevel[i].x);
            line.setAttribute('y1', parentLevel[i].y+18);
            line.setAttribute('x2', childLevel[ci].x);
            line.setAttribute('y2', childLevel[ci].y-18);
            line.setAttribute('stroke', "#b6b6b6");
            line.setAttribute('stroke-width', "2");
            svg.appendChild(line);
          }
        });
      }
    }

    function nextStep() {
      let {value, done} = stepper.next();
      renderTree();
      document.getElementById('desc').innerText = value ? value.desc : '';
      if (done) {
        document.getElementById('nextBtn').disabled = true;
        document.getElementById('desc').innerText += `\n\nMinimax Complete! Root value: ${treeData.value}`;
      }
    }

    function restart() {
      visitState = buildState(treeData);
      highlights = [];
      // Reset all node values except leaves
      treeData.value = null;
      treeData.children.forEach(child => {
        child.value = null;
        child.children.forEach(c2 => {
          // Leaf nodes: keep their value
        });
      });
      stepper = minimaxStep(treeData, visitState, [], true);
      document.getElementById('nextBtn').disabled = false;
      nextStep();
    }

    // Mobile orientation tip
    function showOrientationTip() {
      const orientTip = document.getElementById('orientTip');
      if (window.matchMedia("(max-width: 600px)").matches) {
        if (window.matchMedia("(orientation: portrait)").matches) {
          orientTip.style.display = "block";
        } else {
          orientTip.style.display = "none";
        }
      } else {
        orientTip.style.display = "none";
      }
    }
    window.addEventListener("resize", showOrientationTip);
    window.addEventListener("orientationchange", () => { setTimeout(showOrientationTip, 150); setTimeout(renderTree, 200); });
    document.getElementById('nextBtn').onclick = nextStep;
    document.getElementById('resetBtn').onclick = restart;
    showOrientationTip();
    restart();
  </script>
</body>
</html>
